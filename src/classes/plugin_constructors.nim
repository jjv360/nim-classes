##
## This plugin manages class constructors

{.used.}

import std/macros
import std/tables
import ./internal
import ./plugin_methods
import ./plugin_variables
import ./utils


## Insert autogenerated init functions
proc insertAutogeneratedInits(classDef : ClassDescription) =

    # Check if this class already has an init()
    var hasInit = false
    for methodDef in classDef.methods.definitions:
        if $methodDef.definition.name == "init":
            hasInit = true
            break

    # Insert new autogenerated init() if no init method exists
    if not hasInit:

        # Create blank init method
        var methodDef = Method()
        methodDef.definition = quote do:
            method init()
        methodDef.body = newStmtList()

        # If the superclass has a generic init, make sure to call it
        var parentHasDefaultInit = false
        for m in classDef.superClass.methods.definitions:
            if $m.definition.name == "init" and m.definition.params.len == 2 and $m.definition.params[1].variableName == "this":   # <-- First hidden param is the return type
                parentHasDefaultInit = true
                break

        # If parent has default init, call it in our init body
        if parentHasDefaultInit:
            methodDef.body = newStmtList(quote do:
                super.init()
            )

        # Add it
        classDef.methods.definitions.add(methodDef)



## Automatically insert code to set var values in all init() methods
proc setupVarsInInit(classDef : ClassDescription) =

    # Create code to set up vars
    var initCode = newStmtList()
    for varDef in classDef.vars.definitions:

        # Skip if var has no value
        let valueNode = varDef.definition[2]
        if valueNode.kind == nnkEmpty:
            continue

        # Get name
        var nameDef = varDef.definition.variableName

        # Add the code
        initCode.add(quote do:
            this.`nameDef` = `valueNode`
        )

    # Go through each function
    for methodDef in classDef.methods.definitions:

        # Stop if not an init function
        if $methodDef.definition.name != "init":
            continue

        # Set the return type to our class
        methodDef.definition.params[0] = classDef.name

        # Return 'this' at the end
        methodDef.body.add(quote do:
            return this    
        )

        # Stop if no superclass init code
        if initCode.len == 0:
            continue

        # Find the index of the super call within the method body
        var superIdx = -1
        for i, node in methodDef.body:
            if node.kind == nnkCall and node[0].kind == nnkDotExpr and node[0][0].kind == nnkIdent and $node[0][0] == "super" and node[0][1].kind == nnkIdent and $node[0][1] == "init":
                superIdx = i+1
                break

        # Enforce the use of super.init() within the initializer
        # TODO: This needs work, for now just insert it at the top if not found
        if superIdx == -1:
            superIdx = 0#error("You must call super.init() from within your initializer.", methodDef.definition)

        # Inject the init code after the super call
        methodDef.body.insert(superIdx, initCode)


## Generate the extra init methods
proc generateExtraInits(classDef : ClassDescription) =

    # Go through each function
    for methodDef in classDef.methods.definitions:

        # Stop if not an init function
        if $methodDef.definition.name != "init":
            continue

        # Generate a static init function which just forwards to this one .. format is `ClassName.init()`
        let funcName = ident("init")
        let className = classDef.name
        let underscoreIdent = ident("_")
        var initProc = quote do:
            proc `funcName`*(`underscoreIdent`: typedesc[`className`]): `className` =
                let o = `className`()
                discard o.init()
                return o

        # Add params from the initializer to this wrapper function and to the function it calls
        traverseParams(methodDef.definition, proc(idx : int, nameNode : NimNode, typeNode : NimNode, identDef : NimNode, identDefIdx : int) =
            if idx == 0 and $nameNode == "this": return
            initProc.params.add(newIdentDefs(nameNode, typeNode, newEmptyNode()))
            initProc.body[1][0].add(nameNode)
        )

        # Output it
        classDef.output.add(initProc)


        # Generate a static init function which just forwards to this one .. format is `newClassName()`
        let funcName2 = ident("new" & $className)
        var initProc2 = quote do:
            proc `funcName2`*(): `className` =
                let o = `className`()
                discard o.init()
                return o

        # Add params from the initializer to this wrapper function and to the function it calls
        traverseParams(methodDef.definition, proc(idx : int, nameNode : NimNode, typeNode : NimNode, identDef : NimNode, identDefIdx : int) =
            if idx == 0 and $nameNode == "this": return
            initProc2.params.add(newIdentDefs(nameNode, typeNode, newEmptyNode()))
            initProc2.body[1][0].add(nameNode)
        )

        # Output it
        classDef.output.add(initProc2)



        # Generate a static init function which just forwards to this one .. format is `ClassName.new()`
        let funcName3 = ident("new")
        var initProc3 = quote do:
            proc `funcName3`*(`underscoreIdent`: typedesc[`className`]): `className` =
                let o = `className`()
                discard o.init()
                return o

        # Add params from the initializer to this wrapper function and to the function it calls
        traverseParams(methodDef.definition, proc(idx : int, nameNode : NimNode, typeNode : NimNode, identDef : NimNode, identDefIdx : int) =
            if idx == 0 and $nameNode == "this": return
            initProc3.params.add(newIdentDefs(nameNode, typeNode, newEmptyNode()))
            initProc3.body[1][0].add(nameNode)
        )

        # Output it
        classDef.output.add(initProc3)


## Register the plugin at compile-time
static:
    classCompilerPlugins.add(proc(stage : ClassCompilerStage, classDef : ClassDescription) =
        if stage == ClassCompilerModifyDefinition1: insertAutogeneratedInits(classDef)
        if stage == ClassCompilerModifyDefinition2: setupVarsInInit(classDef)
        if stage == ClassCompilerGenerateOutput1: generateExtraInits(classDef)
    )

